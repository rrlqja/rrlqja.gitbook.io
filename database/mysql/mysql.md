# Mysql

### 트랜잭션

데이터베이스 상태를 바꾸는 작업의 단위\
트랜잭션 수행중 오류가 발생하면 모두 원상태로 복구하고 모두 성공할시에만 데이터베이스에 반영.

1. 원자성 - 트랜잭션이 데이터베이스에 모두 반영되던가 모두 반영되지 않아야함.
2. 일관성 - 트랜잭션 결과가 항상 일관성있어야함.
3. 독립성 - 다른 트랜잭션이 연산에 끼어들수 없다.
4. 영구성 - 트랜잭션 결과는 영구적으로 반영되어야함.

### 페이지

mysql은 데이터를 한곳에 저장하는것이 아닌 page라는 단위로 쪼개서 저장한다.\
page의 기본 용량은 16kb이고, 4kb, 8kb, 32kb, 64kb 등으로 변경할수있다.

### 인덱스

데이터 저장, 수정, 삭제의 성능을 희생하고 검색속도를 높이는 자료구조.

1. 검색 성능을 향상시킨다
2. 인덱스 생성시 추가 공간이 필요함
3. 데이터 변경이나 페이징의 경우 성능이 악화될 수 있음

#### 클러스터드 인덱스(clustered index)

특정 속성을 기준으로 정렬해주는 인덱스.\
테이블 자체가 물리적으로 다시 정렬된다.\
한개의 테이블에 하나의 인덱스만 생성 가능.\
검색속도는 빠르지만 삽입, 수정, 삭제는 느림.\
innodb 에서는 기본키를 자동으로 클러스터드 인덱스로 설정함.

#### 클러스터드 인덱스 생성

클러스터드 인덱스가 생성될때 해당 데이터의 페이지 구조가 변경된다. 페이지는 b-tree 형태의 페이지에 루트 페이지라는 최상위 페이지가 생성되고. 실제 데이터가 존재하는 리프 페이지와 연결된다. 루트 페이지는 리프페이지의 첫번째 데이터만 모아서 매핑되어있다. 리프페이지가 생성될땐 인덱스에 해당하는 속성을 기준으로 다시 정렬되어 생성된다.

페이지를 통한 검색이 가능하여 검색 속도가 빠르다.

데이터 삽입 시 페이지에 공간이 부족하면 페이지 분할이 일어나기 때문에 추가적인 정렬이 필요해진다.

#### 세컨더리 인덱스(non-clustured index)

세컨더리 인덱스는 기존 데이터 페이지는 그대로 둔 상태에서 새로운 별도의 페이지를 생성한다.\
별도의 페이지로 인덱스를 구성하여 클러스터드 인덱스와 다르게 기존 데이터 페이지를 다시 정렬하지않는다.\
클러스터드 인덱스보다 검색속도는 느리지만 삽입, 수정, 삭제는 빠르다.\
세컨더리 인덱스는 여러개를 생성할수있다.

#### 세컨더리 인덱스 생성

세컨더리 인덱스 생성시에도 루트 페이지가 만들어진다. 다만 클러스터드 인덱스와는 다르게 루트 페이지가 데이터 페이지와 바로 연결되어있는게 아닌 추가적인 리프 페이지를 만들어서 루트 페이지와 매핑한다.\
세커더리 인덱스의 리프 페이지는 데이터 페이지의 주소값을 가진다.\
루트 페이지 -> 리프 페이지 -> 데이터 페이지



#### 클러스터드 인덱스 + 세컨더리 인덱스

하나의 테이블에 클러스터드 인덱스와 세컨더리 인덱스를 동시에 사용할 수 있다.\
검색시: 세컨더리 인덱스 루트 페이지 -> 세컨더리 인덱스 리프 페이지 -> 클러스터드 인덱스 루트 페이지 -> 클러스터드 인덱스 리프 페이지(데이터 페이지)

이때 세컨더리 인덱스의 리프 페이지는 데이터 페이지의 주소값을 가지는게 아닌 클러스터드 인덱스 리프 페이지(데이터 페이지)의 인덱스 속성(pk)을 가지고있다.

이렇게 되면 데이터를 검색할때 4개의 페이지를 거쳐 검색을 해야한다. 세컨더리 루트 -> 세컨더리 리프 -> 클러스터드 루트 -> 클러스터드 리프(데이터 페이지). 만약 세컨더리 인덱스 리프 페이지가 pk가 아닌 데이터의 주소를 가지고있다면 세컨더리 루트 -> 세컨더리 리프 -> 클러스더트 리프(데이터 페이지)로 3개의 페이지만으로 검색이 가능할거다. 그런데 왜 세컨더리 리프 페이지는 데이터 페이지의 주소가 아닌 인덱스 속성을 가지고있는것일까?

만약 세컨더리 리프 페이지가 데이터 페이지의 주소값을 가지게된다면 데이터를 삽입, 삭제 등을할때 데이터 페이지의 주소값은 바뀌게되고 이렇게되면 세컨더리 리프 페이지또한 다시 바뀌어야한다.\
하지만 세컨더리 리프 페이지가 인덱스 속성(pk)을 가지게 된다면 세컨더리 리프 페이지의 약간의 정렬만 있으면 된다.\
데이터 페이지의 주소값을 가졌을때의 삽입, 삭제시 잃는 성능이 데이터 페이지의 인덱스 속성(pk)을 가졌을때의 검색 성능보다 더 크기때문에 삽입, 삭제 성능을 보완하고자 데이터 페이지의 주소값을 가지는대신 인덱스 속성(pk)를 가지는 것이다.

요약. 세컨더리 리프 페이지가 데이터 페이지의 주소값을 가지면 삽입, 삭제 등의 성능이 크게 하락됨. 그래서 데이터 페이지의 pk값을 가지고 이를 가지고 클러스터드 루트 페이지를 통해 검색함.



#### 인덱스가 필요한 상황

1. where 절에 자주 사용되는 열
2. select 절에 자주 등장하는 컬럼
3. join 절에 자주 사용되는 열
4. order by 절에 자주 사용되는 열

#### 인덱스를 사용하지 말아야할 상황

1. 대용량 데이터가 자주 입력되는 경우
2. 데이터 중복도가 높은 열
3. 자주 사용되지 않을경우

#### 인덱스 주의점

데이터 변경이 얼마나 자주 일어나는지 고려해야함\
인덱스가 많으면 오히려 속도가 느려질수있음\
검색할 데이터가 전체 데이터의 20% 이상일 시 사용 X. 강제로 사용할 경우 성능이 저하됨.\
사용하지 않는 인덱스는 삭제해야함.\
클러스터드 인덱스는 테이블당 한개만 생성 가능.



